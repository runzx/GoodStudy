JavaScript 模块的循环加载
    循环加载"（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。
    为了防止模块载入的死循环，Node.js 在模块第一次载入后会把它的结果进行缓存，
        下一次再对它进行载入的时候会直接从缓存中取出结果。
        所以在这种循环依赖情形下，不会有死循环，
        但是却会因为缓存造成模块没有按照我们预想的那样被导出（export，详细的案例分析见下文）。
    为了避免无限循环的模块依赖，在 Node.js 运行 A.js 之后，它就被缓存了，但需要注意的是，此时缓存的仅仅是一个未完工的 A.js（an unfinished copy of the a.js）。所以在 B.js require A.js 时，得到的仅仅是缓存中一个未完工的 A.js，具体来说，它并没有明确被导出的具体内容（A.js 尾端）。所以 B.js 中输出的 a 是一个空对象。

解决问题
    想要解决这个问题有一个很简明的方法，那就是在循环依赖的每个模块中
        先导出自身，--  把exports.xxx = 放到 require()前面 --
    然后再导入其他模块（对于本文的举例来说，实际只需改动 A.js 就可以达到效果）。
    这种解决办法可行的原因也很简单，还是因为 JavaScript 是一门解释型的语言，
        在 require 其他模块之前，已经把自身需要导出的部分都导出了，
        所以即便有模块载入缓存，也不影响最终结果按预期进行。

    这种办法几乎没什么副作用，唯一稍令强迫症感到不快就是这种顺序与我们通常的书写顺序不符。
        一般我们都会先把 require 写在源文件开头，exports 放到后面的位置。

    ES6 import
        ES6模块的运行机制与CommonJS不一样，它遇到模块加载命令import时，
            不会去执行模块，而是只生成一个引用。
            等到真的需要用到时，再到模块里面去取值。
        因此，ES6模块是动态引用，不存在缓存值的问题，
            而且模块里面的变量，绑定其所在的模块。请看下面的例子。
