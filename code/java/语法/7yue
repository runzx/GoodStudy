软件工程：
    目的  迭代， 维护
    可维护的代码

   java,C#
    强制性，

   好代码：
    不啰嗦， 自描述的代码， 可维护性好

   好维护
    开闭原则    Open Closed principle (OCP)
        里式替换原则， 迪米特法则， IOC, DI

        新增类/业务模块 代替原来的类/模块

        面向抽象编程:
            inteface
            abstract


    1。interface 统一方法的调用，它不能统一对象的实例化

    2。面向对象    实例化对象   调用方法(完成业务逻辑)  (这是面向对象主要做的2件事)

    3。只有一段代码中没有new的出现，才能保持代码的相对稳定，才能逐步实现OCP

    4。上面的这句话只是表象，实质中一段代码如果要保持稳定，就不应该负责对象的实例化。

    5。对象的实例化是不可能消除的

    6。把对象的实例化教程，转移到其它的代码片段里

    7。代码中总是会存在不稳定，隔离这些不稳定，保证其它的代码是稳定的

    不稳定原因是软件中的变化！ 用户的选择(输入，操作)、 系统技术选择(升级，选型)
    8。变化造成了不稳定
    计算机的代码 反映 现实世界的规律， 业务的映射，投影。
        new 对象 模拟业务
    反射技术 reflect
    元类：描述一个类
    String classStr="reflect.hero."+name;
    Class<?> cla=Class.forName(classStr);
    Object obj=cla.newInstance();

    抽象工厂    factory

    IOC 抽象
    DI 实现

    主控类 A里new C, A为主控类
        IOC 容器 为主控方， 在里面new A, C, 实现控制反转

    控制权
        程序员     用户
        控制代码/新增业务代码
        程序员只负责写类， 用哪个类由产品经理或用户来决定， 这是控制反转

        配置文件    属于外部文件，不属于代码本身，理解为用户输入，变化隔离到配置文件中

    IoC(控制反转) 、DI(依赖注入)、DIP(依赖倒置)
        以前是我们向容器要对象
        容器主动提供对象给我们(反转)，

        DIP Dependency Inversion Principle
            高层模块不应该依赖低层模块，两者都应该依赖抽象
                抽象是高层，
            抽象不应该依赖细节
            细节应该依赖抽象
        DI Dependecy Injection
            属性注入 setIC()
            构造注入 构造函数来注入
            接口注入    用的很少

            continer 容器里new ,外部，装配一个个类，把类从类中取出，(接口)抽象， 让容器来new 装配:注入到类中，
