
1. () 表示执行或表达式
    // 函数声明（会提前）
    function func(){
        // ...
    }
    // 函数表达式（不会提前，只有此后的代码才能使此定义函数 func）
    var func=function(){        // 有运算符号 =
        // ...
    }
    要区分一个代码是函数声明还是函数表达式，那要看代码的应用上下文。
        如果有运算符号，那它就是函数表达式。
        如果没有运算符号而且不在条件判断语句中，就说明是函数声明，无法直接加()进行调用（运算符包括赋值号跟括号）
        如果在条件语句中，函数声明也会强行被当做函数表达式执行。
    三种自执行函数
    (function(){
        //代码1
    })();
        // (function(){})是一个表达式，会强制其理解成函数直接量方式，也就是表达式方式创建函数，
            (function(){})它会返回函数对象的引用，最后使用小括号()调用此函数。
    
    (function(){
        //代码2
    }());
        // (function(){}())，如果不用外面包裹的小括号，{}就会理解为复合语句，那么function(){}就被理解为函数声明，但是没有标识符，所以会报错，
            使用小括号以后，就会变成表达式，也会被理解为直接量方式。

    !function(){
        //代码3
    }();
        // !也是一个运算符，所以在原理同上。还可以有其他运算符。
            所以只要通过运算符将语句改成了该表达式，不管这是个什么样的表达式
                < (,),-,+, >，都会先返回函数体的引用，然后再执行其他操作，如进行调用()*

    上面三个语句都是在运算符相关上下文中，所以都是表达式，就可以强制调用了
    
    // 但是如果存在运算符号<(,),-,+,*>则是先忽略执行函数的 () 
    var x = function (){console.log(123)}();
    var y = function asdfas(){console.log(123)}();

    // 效果类似于先将函数体的地址拿到类似于
    var x = function (){console.log(123)};// 拿到了函数体的地址
    var y = function asdfas(){console.log(123)};// 拿到了函数体的地址

    // 通过地址进行调用
    x();
    y();

    如果执行 (0, foo.bar)()，这个逗号表达式等价于执行 foo.bar()，
        但是执行时的上下文环境会被绑定到全局对象身上，
        所以实际上真正等价于执行 foo.bar.call(GLOBAL_OBJECT)。
    (0, _assert2['default'])这样做是为了使A行中的调用是函数调用，
        而不是方法调用（with this === _assert2）。

