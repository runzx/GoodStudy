

1. 
    PHP 是同步的（当然现在也能实现异步编程，如 Swoole，并且性能不比 Node 差），一般依赖 Apache 或是 Nginx 作为 Web Server，
        每个请求都发生在由 php-fpm 管理的独立的 PHP 进程上，请求结束后释放加载的资源，
            所以无论是全局变量还是全局函数，都只会对当前请求有效
    Node 来说，它常驻内存，自身就是 Web Server，
        所以定义全局变量与函数自然会影响到所有的请求，
        尤其是同时发生的。

2. Js 数据结构
    ① 类型转换
        Js 与 PHP 一样无需声明变量类型以及支持自动转换，
            PHP：字符串拼接用 .，数值相加用 +，根据运算符来决定转换结果，清晰明了，
            Js 只能用 +，这导致只要因数中存在字符串，最后的结果就只能是字符串。
                一元正号 (+)
    ② 数组
        Js 中的数组并不支持 键值对，这导致在 PHP 中用数组能办到的很多事在 Js 中只能使用对象，虽然 ES6 引入了 Map 数据结构，但构造方法太反人类，存取值的方式也不方便，我认为它在大多数情况下还没有 数组+对象 好用
        另外值得一提的是我们通常用 typeof 关键字来获取 Js 的数据类型，但是 数组 和 对象 均返回 object，所以对于数组，
            一般使用 Array.isArray() 方法来判断
        对于简单的用于 键值对 的对象使用 for...in，
            对于 Array、Map 等内置对象时使用 for...of 是个比较好的选择
3. 类与继承
    ES6 提供了类与继承的语言级实现，但相比 PHP 的类还有以下差别：
    不支持接口
    不支持私有方法，解决方案： 将私有方法移出类，通过 call 方法来调用
    不支持私有属性，目前已有提案，将支持私有属性与私有方法
    不支持静态属性，解决方案：
        class Foo {
            //
        }
        Foo.bar = 1;
        console.log(Foo.bar); // 1
    ES6 也提供了 Proxy 与 Reflect 对象，用于拦截与定义基本操作的默认行为，等同于在语言层面做出修改
