

1.
6. 调试模式
    虽然 run() 方法适用于启动本地的开发服务器，但是你每次修改代码后都要手动重启它。这样并不够优雅，而且 Flask 可以做到更好。
    如果你启用了调试支持，服务器会在代码修改后自动重新载入，并在发生错误时提供一个相当有用的调试器。
    有两种途径来启用调试模式。一种是直接在应用对象上设置:
        app.debug = True
        app.run()
    另一种是作为 run 方法的一个参数传入:
        app.run(debug=True)
    重载只针对.py代码文件，模版文件变动不会重载！
        flask 0.11 改动了设置, 这样只能重载 python 文件, 不能连模版文件一起重载.
        要想模版文件一起重载需要设置 TEMPLATES_AUTO_RELOAD 这个配置(Flask Changelog).
            app.config['TEMPLATES_AUTO_RELOAD'] = True
        但是使用后还发现如果是 include 进来的模版改动后还是不能重载.
            必须要这样设置才可以:
            app.config['DEBUG'] = True
        所以推荐使用配置文件的形式引入配置:
        config.py
            DEBUG = True
            TEMPLATES_AUTO_RELOADT = True

        app.py
            app.config.from_pyfile('config.py')
            app.run()
        还有就是静态文件被缓存了,例如 css, js 这些文件改动后，刷新网页也看不到改动后的效果.
        可以在文件名后面加入随机字符, 可以看看 static url cache buster.
7. 模板渲染    # http://docs.jinkan.org/docs/flask/quickstart.html#id7
    Flask 会在 templates 文件夹里寻找模板。
        所以，如果你的应用是个模块，这个文件夹应该与模块同级；
        如果它是一个包，那么这个文件夹作为包的子目录:
            情况 1: 模块:
                /application.py
                /templates
                    /hello.html
            情况 2: 包:
                /application
                    /__init__.py
                    /templates
                        /hello.html
    在模板里，你也可以访问 request 、 session 和 g [1] 对象， 以及 get_flashed_messages() 函数。
    自动转义功能默认是开启的，所以如果 name 包含 HTML ，它将会被自动转义。
        如果你能信任一个变量，并且你知道它是安全的（例如一个模块把 Wiki 标记转换为 HTML），
        你可以用 Markup 类或 |safe 过滤器在模板中把它标记为安全的。

8. 使用其他CDN
    换成cdn.bootcss.com提供的资源：
        bootstrap = lwrap(
            WebCDN('//cdn.bootcss.com/bootstrap/%s/' % BOOTSTRAP_VERSION), local)
        jquery = lwrap(
            WebCDN('//cdn.bootcss.com/jquery/%s/' % JQUERY_VERSION), local)
        html5shiv = lwrap(
            WebCDN('//cdn.bootcss.com/html5shiv/%s/' % HTML5SHIV_VERSION))
        respondjs = lwrap(
            WebCDN('//cdn.bootcss.com/respond.js/%s/' % RESPONDJS_VERSION))
    加载本地资源
        app = Flask(__name__)
        app.config['BOOTSTRAP_SERVE_LOCAL'] = True
9. error
    1) jinja2.exceptions.UndefinedError: 'bootstrap_find_resource' is undefined
        old: from flask.ext.bootstrap import Bootstrap
        改成：from flask_bootstrap import Bootstrap

10. 配置文件
    JSON_AS_ASCII	
        默认True: Flask将对象序列化为ASCII编码的JSON。
        设False：Flask将不会编码为ASCII和输出字符串，并返回unicode字符串。 jsonify将会自动对其进行编码，以utf-8 进行传输。

        flask提供了jsonify函数供用户处理返回的序列化json数据，
            将我们传入的json形式数据序列化成为json字符串，作为响应的body，并且设置响应的Content-Type为application/json，构造出响应返回至客户端。
            Content-Type字段值为application/json，而使用json.dumps时该字段值为text/html。
        而python自带的json库中也有dumps方法可以序列化json对象
            

    JSON_SORT_KEYS	默认情况下，Flask将以按键排序的方式对JSON对象进行序列化。这样做是为了确保独立于字典的哈希种子的返回值将一致，不会垃圾外部HTTP缓存。您可以通过更改此变量覆盖默认行为。这是不推荐的，但可能会提高性能提高可缓存性的成本。
11. 变量规则
    要给 URL 添加变量部分，你可以把这些特殊的字段标记为 <variable_name> ， 这个部分将会作为命名参数传递到你的函数。
    规则可以用 <converter:variable_name> 指定一个可选的转换器。
        转换器有下面几种：
            int	接受整数
            float	同 int ，但是接受浮点数
            path	和默认的相似，但也接受斜线
12. 唯一 URL / 重定向行为
    访问一个结尾不带斜线的 URL 会被 Flask 重定向到带斜线的规范 URL 去。
        app里设定route('/xxx/')以'/'结尾是好习惯，可以让用户以 www.abc.com/xxx 也能访问到。
    这个行为使得在遗忘尾斜线时，允许关联的 URL 接任工作，