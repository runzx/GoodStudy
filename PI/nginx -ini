//  /etc/nginx/sites-available/default.conf


##
# You should look at the following URL's in order to grasp a solid understanding
# of Nginx configuration files in order to fully unleash the power of Nginx.
# http://wiki.nginx.org/Pitfalls
# http://wiki.nginx.org/QuickStart
# http://wiki.nginx.org/Configuration
#
# Generally, you will want to move this file somewhere, and start with a clean
# file but keep this around for reference. Or just disable in sites-enabled.
#
# Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.
##

# Default server configuration
#
server {
	listen 80 default_server;
	listen [::]:80 default_server;

	# SSL configuration
	#
	# listen 443 ssl default_server;
	# listen [::]:443 ssl default_server;
	#
	# Self signed certs generated by the ssl-cert package
	# Don't use them in a production server!
	#
	# include snippets/snakeoil.conf;

	root /var/www/html;

	# Add index.php to the list if you are using PHP
	index index.html index.htm index.nginx-debian.html;

	server_name _;

	location / {
		# First attempt to serve request as file, then
		# as directory, then fall back to displaying a 404.
		try_files $uri $uri/ =404;
	}

	# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
	#
	#location ~ \.php$ {
	#	include snippets/fastcgi-php.conf;
	#
	#	# With php5-cgi alone:
	#	fastcgi_pass 127.0.0.1:9000;
	#	# With php5-fpm:
	#	fastcgi_pass unix:/var/run/php5-fpm.sock;
	#}

	# deny access to .htaccess files, if Apache's document root
	# concurs with nginx's one
	#
	#location ~ /\.ht {
	#	deny all;
	#}
}


# Virtual Host configuration for example.com
#
# You can move that to a different file under sites-available/ and symlink that
# to sites-enabled/ to enable it.
#
#server {
#	listen 80;
#	listen [::]:80;
#
#	server_name example.com;
#
#	root /var/www/example.com;
#	index index.html;
#
#	location / {
#		try_files $uri $uri/ =404;
#	}
#}

FastCGI
FastCGI，也称为FCGI，是一个外部服务与Web服务器的接口协议。FastCGI是早期的通用网关接口(CGI)的增强版本。 
    FastCGI致力于减少网页服务器与CGI程序之间的开销，从而使服务器可以同时处理更多的网页请求。
PHP 集成
    有不同的方式可以启动PHP FastCGI服务,我们将介绍php-fpm.这也是推荐的方案.
     location ~ \.php$ {
        fastcgi_pass   unix:/run/php-fpm/php-fpm.sock;
        fastcgi_index  index.php;
        include        fastcgi.conf;
 }

    或者,你可以使用常用的TCP套接字,不是默认:
        fastcgi_pass 127.0.0.1:9000;

        PHP-FPM也是一个第三方的FastCGI进程管理器，它是作为PHP的一个补丁来开发的，在安装的时候也需要和PHP源码一起编译，也就是说PHP-FPM被编译到PHP内核中，因此在处理性能方面更加优秀；
            同时它在处理高并发方面也比spawn-fcgi引擎好很多，因此，推荐Nginx+PHP/PHP-FPM这个组合对PHP进行解析。
        FastCGI 的主要优点是把动态语言和HTTP Server分离开来，所以Nginx与PHP/PHP-FPM经常被部署在不同的服务器上，以分担前端Nginx服务器的压力，
            使Nginx专一处理静态请求和转发动态请求，而PHP/PHP-FPM服务器专一解析PHP动态请求。

        fastcgi_param指令指定放置PHP动态程序的主目录，也就是$fastcgi_script_name前面指定的路径，这里是/usr/local/nginx/html目录，建议将这个目录与Nginx虚拟主机指定的根目录保持一致，当然也可以不一致。
            fastcgi_params文件是FastCGI进程的一个参数配置文件，在安装Nginx后，会默认生成一个这样的文件，这里通过include指令将FastCGI参数配置文件包含了进来。
        
    模拟PATH_INFO:
        Nginx 是不支持PATH INFO的, 对于一些使用PATH_INFO来传递关键信息的PHP框架来说(比如Kohana, Thinkphp), 简直是致命的.
        解决方法:
            第一种就是使用rewrite, 但是这个方法的缺点也是很明显的, 需要把PATH_INFO转换成Query String. 
            第二种方法是 模拟PATH_INFO:
                对于形如/laruence/info.php/pathinfo这样的文件路径, Nginx是不会正确的交给php cgi服务器的. 所以我们需要改写这段配置为:
                location ~ .php {//片段匹配
                    fastcgi_index  index.php;
                    fastcgi_pass   127.0.0.1:9000;
                    include        fastcgi_params;
                }

                首先, 我们需要打开PHP中cgi.fix_pathinfo配置项, 打开这个配置项以后, PHP会去根据CGI规范来检查SCRIPT_FILENAME中那部分是访问脚本和PATH_INFO(ini配置解释), 并根据SCRIPT_NAME来修改PATH_INFO(和PATH_TRANSLATED)为正确的值(其实也就是说明, PHP最初对CGI 1.1的支持并不到位)
                然后, 就只要添加一个FASTCGI_PARAM项就好了:
                location ~ .php {
                    fastcgi_index  index.php;
                    fastcgi_pass   127.0.0.1:9000;
                    include        fastcgi_params;
                    fastcgi_param  PATH_INFO $fastcgi_script_name;
                }

            第三种方法: 对路径的分析交给了PHP去处理, 网上也有朋友给出了另外一种配置方法, 这个方法是由Nginx来分析路径(也就不需要fix_pathinfo):
                location ~ \.php {
                    fastcgi_index index.php;
                    fastcgi_pass 127.0.0.1:9000;
                    include      fastcgi_params;
                    set $path_info "";
                    set $real_script_name $fastcgi_script_name;
                    if ($fastcgi_script_name ~ "^(.+?\.php)(/.+)$") {
                    set $real_script_name $1;
                    set $path_info $2;
                }
                fastcgi_param SCRIPT_FILENAME /var/html/$real_script_name;
                fastcgi_param SCRIPT_NAME $real_script_name;
                fastcgi_param PATH_INFO $path_info;
                }

        
nginx配置基础
    1、正则表达式匹配
        ~  区分大小写匹配
        ~* 不区分大小写匹配
        !~和!~*分别为区分大小写不匹配及不区分大小写不匹配
        ^  以什么开头的匹配
        $  以什么结尾的匹配
        \  转义字符。可以转. * ?等
        *  代表任意字符

    2、文件及目录匹配
        -f和!-f用来判断是否存在文件
        -d和!-d用来判断是否存在目录
        -e和!-e用来判断是否存在文件或目录
        -x和!-x用来判断文件是否可执行
    例:
        location = /                        #匹配任何查询，因为所有请求都已 / 开头。但是正则表达式规则和长的块规则将被优先和查询匹配
        location ^~ /images/ {              # 匹配任何已/images/开头的任何查询并且停止搜索。任何正则表达式将不会被测试。
        location ~* \.(gif|jpg|jpeg)$ {     # 匹配任何已.gif、.jpg 或 .jpeg 结尾的请求

        #注：与 { 要有空格，否则会出错

     3.nginx禁止访问某类文件
        方法一:
        location ~* \.(txt|doc)$ {
            if (-f $request_filename) {
                root /usr/local/nginx/html/test;
                break;
            }
        }
        方法二
        location ~* \.(txt|doc)$ {
           root /usr/local/nginx/html/test;
           deny all;
        }
    4. nginx静态文件处理
        第一种方法:根据文件类型expires
        location ~* \.(js|css|jpg|jpeg|gif|png|swf)$ {
            if (-f $request_filename) {
                root /usr/local/nginx/html/;
                expires 1d;
        }
        break;
        }
        第二种方法:根据判断某个目录
        location ~ ^/(images|javascript|js|css|flash|media|static)/ {
            root /usr/local/nginx/html/;
            expires 30d;
        }
    
    nginx防盗链
        一般的防盗链如下：
        location ~* .(gif|jpg|png|swf|flv)$ {
            valid_referers none blocked server_names *.koumm.com www.koumm.com;
                if ($invalid_referer) {
                rewrite ^/ http://www.koumm.com/403.html;
                #return 404;
            }
        }

    因此不再建议大家使用以下方式（搜了一下，网上大量的文章，并且nginx.conf的默认配置也是使用这种方式）：
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    而使用最新的方式：
        include fastcgi.conf;