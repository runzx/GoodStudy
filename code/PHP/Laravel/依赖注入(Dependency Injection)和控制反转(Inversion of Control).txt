

1. 依赖注入(Dependency Injection)和控制反转(Inversion of Control)是同一个概念。 
	具体含义是当某个角色(可能是一个Java实例，调用者)需要另一个角色(另一个Java实例，被调用者)的协助时，在传统的程序设计过程中，通常由调用者来创建被调用者的实例。2008年4月28日
	依赖注入和控制反转说的实际上是同一个东西，它们是一种设计模式，这种设计模式用来减少程序间的耦合
	使用依赖注入，最重要的一点好处就是有效的分离了对象和它所需要的外部资源，使得它们松散耦合，有利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。
	依赖注入和控制反转是对同一件事情的不同描述，从某个方面讲，就是它们描述的角度不同。
		依赖注入是从应用程序的角度在描述，可以把依赖注入，即：
			应用程序依赖容器创建并注入它所需要的外部资源；
		而控制反转是从容器的角度在描述，即：
			容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。
	问答：
		1）整个过程中参与者都有谁？
			一般有三方参与者，一个是某个对象；一个是IoC/DI的容器；另一个是某个对象的外部资源。
			某个对象指的就是任意的、普通的PHP对象; 
			IoC/DI的容器简单点说就是指用来实现IoC/DI功能的一个框架程序；
			对象的外部资源指的就是对象需要的，但是是从对象外部获取的，都统称资源，比如：对象需要的其它对象、或者是对象需要的文件资源等等。
		2）谁依赖于谁：
			当然是某个对象依赖于IoC/DI的容器
		3）为什么需要依赖：
			对象需要IoC/DI的容器来提供对象需要的外部资源
		4）谁注入于谁：
			是IoC/DI的容器 注入 某个对象
		5）到底注入什么：
			就是注入某个对象所需要的外部资源
		6）谁控制谁：
			当然是IoC/DI的容器来控制对象了
		7）控制什么：
			主要是控制对象实例的创建
		8）为何叫反转：
			反转是相对于正向而言的，那么什么算是正向的呢？
			考虑一下常规情况下的应用程序，如果要在A里面使用C，你会怎么做呢？当然是直接去创建C的对象，也就是说，
				是在A类中主动去获取所需要的外部资源C（$c = new C();），这种情况被称为正向的。
				那么什么是反向呢？就是A类不再主动去获取C，而是被动等待，等待IoC/DI的容器获取一个C的实例，然后反向的注入到A类中。
			用（反转-图示）例来说明一下，先看没有IoC/DI的时候，常规的A类使用C类的示意图，如下图所示：
2. 例子：
	(1)原始社会里，几乎没有社会分工。需要斧子的人(调用者)只能自己去磨一把斧子(被调用者)。对应的情形为:Java程序里的调用者自己创建被调用者。
	(2)进入工业社会，工厂出现。斧子不再由普通人完成，而在工厂里被生产出来，此时需要斧子的人(调用者)找到工厂，购买斧子，无须关心斧子的制造过程。对应Java程序的简单工厂的设计模式。
	(3)进入“按需分配”社会，需要斧子的人不需要找到工厂，坐在家里发出一个简单指令:需要斧子。斧子就自然出现在他面前。对应Spring的依赖注入。

	第一种情况下，Java实例的调用者创建被调用的Java实例，必然要求被调用的Java类出现在调用者的代码里。无法实现二者之间的松耦合。
	第二种情况下，调用者无须关心被调用者具体实现过程，只需要找到符合某种标准(接口)的实例，即可使用。此时调用的代码面向接口编程，可以让调用者和被调用者解耦，这也是工厂模式大量使用的原因。但调用者需要自己定位工厂，调用者与特定工厂耦合在一起。
	第三种情况下，调用者无须自己定位工厂，程序运行到需要被调用者时，系统自动提供被调用者实例。事实上，调用者和被调用者都处于Spring的管理下，二者之间的依赖关系由Spring提供。
	所谓依赖注入，是指程序运行过程中，如果需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部的注入。Spring的依赖注入对调用者和被调用者几乎没有任何要求，完全支持对POJO之间依赖关系的管理。依赖注入通常有两种:
		·设值注入。
			设值注入是指通过setter方法传入被调用者的实例。这种注入方式简单、直观，因而在Spring的依赖注入里大量使用。看下面代码，是Person的接口
				//定义Person接口
				public interface Person
				{
					//Person接口里定义一个使用斧子的方法
					public void useAxe();
				}

		·构造注入。
			所谓构造注入，指通过构造函数来完成依赖关系的设定，而不是通过setter方法。对前面代码Chinese类做简单的修改，修改后的代码如下:
				//Chinese实现Person接口
				public class Chinese implements Person
				{
					//面向Axe接口编程，而不是具体的实现类
					private Axe axe;
					//默认的构造器
					public Chinese()
					{}
					//构造注入所需的带参数的构造器
					public Chinse(Axe axe)
					{
					this.axe = axe;
					}
					//实现Person接口的useAxe方法
					public void useAxe()
					{
					System.out.println(axe.chop());
					}
				}

3. 注解（Annotation）

	注解的概念

	注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK 1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。

	注解的作用

		1)、标记作用，用于告诉编译器一些信息让编译器能够实现基本的编译检查，如@Override、Deprecated，看下它俩的源码

			@Target(ElementType.METHOD)
			@Retention(RetentionPolicy.SOURCE)
			public @interface Override {
			}

			@Documented
			@Retention(RetentionPolicy.RUNTIME)
			public @interface Deprecated {
			}
		2)、编译时动态处理，动态生成代码，如Butter Knife、Dagger 2

		3)、运行时动态处理，获得注解信息，如Retrofit
	第一种分法
		1、基本内置注解，是指Java自带的几个Annotation，如@Override、Deprecated、@SuppressWarnings等
		2、元注解（meta-annotation），是指负责注解其他注解的注解，JDK 1.5及以后版本定义了4个标准的元注解类型，如下：
			1、@Target
			2、@Retention
			3、@Documented
			4、@Inherited
	第二种分法，根据作用域分类
		1、源码时注解（RetentionPolicy.SOURCE）
		2、编译时注解（RetentionPolicy.CLASS）
		3、运行时注解（RetentionPolicy.RUNTIME）
4. 术语介绍
	非侵入性 No intrusive
		框架的目标之一是非侵入性（No intrusive）
		组件可以直接拿到另一个应用或框架之中使用
		增加组件的可重用性（Reusability）
	容器（Container）
		管理对象的生成、资源取得、销毁等生命周期
		建立对象与对象之间的依赖关系
		启动容器后，所有对象直接取用，不用编写任何一行代码来产生对象，或是建立对象之间的依赖关系。
	IoC
		控制反转 Inversion of Control
		依赖关系的转移
		依赖抽象而非实践
	DI
		依赖注入 Dependency Injection
		不必自己在代码中维护对象的依赖
		容器自动根据配置，将依赖注入指定对象
	AOP
		Aspect-oriented programming
		面向方面编程
		无需修改任何一行程序代码，将功能加入至原先的应用程序中，也可以在不修改任何程序的情况下移除。
	分层
		表现层：提供服务，显示信息。
		领域层：逻辑，系统中真正的核心。
		数据源层：与数据库、消息系统、事务管理器及其它软件包通信。
		——《企业应用架构模式》P.14

5. 软件架构支持技术（开发软件时要遵循的基本原则）
	抽象
	封装
	信息隐藏
	分离关注点
	耦合与内聚
	充分、完整、简单
	策略与实现分离
		策略组件负责上下文相关决策，解读信息的语义和含义，将众多不同结果合并或选择参数值
		实现组件负责执行定义完整的算法，不需要作出与上下文相关的决策。上下文和解释是外部的，通常由传递给组件的参数提供。
	接口与实现分离
		接口部分定义了组件提供的功能以及如何使用该组件。组件的客户端可以访问该接口。
		实现部分包含实现组件提供的功能的实际代码，还可能包含仅供组件内部使用的函数和数据结构。组件的客户端不能访问其实现部分。
	单个引用点
		软件系统中的任何元素都应只声明和定义一次，避免不一致性问题。
	分而治之
6. 软件架构的非功能特性
		可修改性
		可维护性
		可扩展性
		重组
		可移植性
	互操作性
		与其它系统或环境交互
	效率
	可靠性
		容错：发生错误时确保行为正确并自行修复
		健壮性：对应用程序进行保护，抵御错误的使用方式和无效输入，确保发生意外错误时处于指定状态。
	可测试性
	可重用性
		通过重用开发软件
		开发软件时考虑重用